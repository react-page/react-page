/* skel.js v3.0.1 | (c) skel.io | MIT licensed */
const skel = (function () { const t = { breakpointIds: null, events: {}, isInit: !1, obj: { attachments: {}, breakpoints: {}, head: null, states: {} }, sd: '/', state: null, stateHandlers: {}, stateId: '', vars: {}, DOMReady: null, indexOf: null, isArray: null, iterate: null, matchesMedia: null, extend(e, n) { t.iterate(n, (i) => { t.isArray(n[i]) ? (t.isArray(e[i]) || (e[i] = []), t.extend(e[i], n[i])) : typeof n[i] == 'object' ? (typeof e[i] != 'object' && (e[i] = {}), t.extend(e[i], n[i])) : e[i] = n[i] }) }, newStyle(t) { const e = document.createElement('style'); return e.type = 'text/css', e.innerHTML = t, e }, _canUse: null, canUse(e) { t._canUse || (t._canUse = document.createElement('div')); let n = t._canUse.style, i = e.charAt(0).toUpperCase() + e.slice(1); return e in n || `Moz${i}` in n || `Webkit${i}` in n || `O${i}` in n || `ms${i}` in n }, on(e, n) { const i = e.split(/[\s]+/); return t.iterate(i, (e) => { const a = i[e]; if (t.isInit) { if (a == 'init') { return void n() } if (a == 'change') { n() } else { const r = a.charAt(0); if (r == '+' || r == '!') { const o = a.substring(1); if (o in t.obj.breakpoints) { if (r == '+' && t.obj.breakpoints[o].active) { n() } else if (r == '!' && !t.obj.breakpoints[o].active) { return void n() } } } } }t.events[a] || (t.events[a] = []), t.events[a].push(n) }), t }, trigger(e) { return t.events[e] && t.events[e].length != 0 ? (t.iterate(t.events[e], (n) => { t.events[e][n]() }), t) : void 0 }, breakpoint(e) { return t.obj.breakpoints[e] }, breakpoints(e) { function n(t, e) { this.name = this.id = t, this.media = e, this.active = !1, this.wasActive = !1 } return n.prototype.matches = function () { return t.matchesMedia(this.media) }, n.prototype.sync = function () { this.wasActive = this.active, this.active = this.matches() }, t.iterate(e, (i) => { t.obj.breakpoints[i] = new n(i, e[i]) }), window.setTimeout(() => { t.poll() }, 0), t }, addStateHandler(e, n) { t.stateHandlers[e] = n }, callStateHandler(e) { const n = t.stateHandlers[e](); t.iterate(n, (e) => { t.state.attachments.push(n[e]) }) }, changeState(e) { t.iterate(t.obj.breakpoints, (e) => { t.obj.breakpoints[e].sync() }), t.vars.lastStateId = t.stateId, t.stateId = e, t.breakpointIds = t.stateId === t.sd ? [] : t.stateId.substring(1).split(t.sd), t.obj.states[t.stateId] ? t.state = t.obj.states[t.stateId] : (t.obj.states[t.stateId] = { attachments: [] }, t.state = t.obj.states[t.stateId], t.iterate(t.stateHandlers, t.callStateHandler)), t.detachAll(t.state.attachments), t.attachAll(t.state.attachments), t.vars.stateId = t.stateId, t.vars.state = t.state, t.trigger('change'), t.iterate(t.obj.breakpoints, (e) => { t.obj.breakpoints[e].active ? t.obj.breakpoints[e].wasActive || t.trigger(`+${e}`) : t.obj.breakpoints[e].wasActive && t.trigger(`-${e}`) }) }, generateStateConfig(e, n) { const i = {}; return t.extend(i, e), t.iterate(t.breakpointIds, (e) => { t.extend(i, n[t.breakpointIds[e]]) }), i }, getStateId() { let e = ''; return t.iterate(t.obj.breakpoints, (n) => { const i = t.obj.breakpoints[n]; i.matches() && (e += t.sd + i.id) }), e }, poll() { let e = ''; e = t.getStateId(), e === '' && (e = t.sd), e !== t.stateId && t.changeState(e) }, _attach: null, attach(e) { let n = t.obj.head, i = e.element; return i.parentNode && i.parentNode.tagName ? !1 : (t._attach || (t._attach = n.firstChild), n.insertBefore(i, t._attach.nextSibling), e.permanent && (t._attach = i), !0) }, attachAll(e) { const n = []; t.iterate(e, (t) => { n[e[t].priority] || (n[e[t].priority] = []), n[e[t].priority].push(e[t]) }), n.reverse(), t.iterate(n, (e) => { t.iterate(n[e], (i) => { t.attach(n[e][i]) }) }) }, detach(t) { const e = t.element; return t.permanent || !e.parentNode || e.parentNode && !e.parentNode.tagName ? !1 : (e.parentNode.removeChild(e), !0) }, detachAll(e) { const n = {}; t.iterate(e, (t) => { n[e[t].id] = !0 }), t.iterate(t.obj.attachments, (e) => { e in n || t.detach(t.obj.attachments[e]) }) }, attachment(e) { return e in t.obj.attachments ? t.obj.attachments[e] : null }, newAttachment(e, n, i, a) { return t.obj.attachments[e] = { id: e, element: n, priority: i, permanent: a } }, init() { t.initMethods(), t.initVars(), t.initEvents(), t.obj.head = document.getElementsByTagName('head')[0], t.isInit = !0, t.trigger('init') }, initEvents() { t.on('resize', () => { t.poll() }), t.on('orientationChange', () => { t.poll() }), t.DOMReady(() => { t.trigger('ready') }), window.onload && t.on('load', window.onload), window.onload = function () { t.trigger('load') }, window.onresize && t.on('resize', window.onresize), window.onresize = function () { t.trigger('resize') }, window.onorientationchange && t.on('orientationChange', window.onorientationchange), window.onorientationchange = function () { t.trigger('orientationChange') } }, initMethods() { document.addEventListener ? !(function (e, n) { t.DOMReady = n() }('domready', () => { function t(t) { for (r = 1; t = n.shift();) { t() } } let e, n = [], i = document, a = 'DOMContentLoaded', r = (/^loaded|^c/).test(i.readyState); return i.addEventListener(a, e = function () { i.removeEventListener(a, e), t() }), function (t) { r ? t() : n.push(t) } })) : !(function (e, n) { t.DOMReady = n() }('domready', (t) => { function e(t) { for (h = 1; t = i.shift();) { t() } } let n, i = [], a = !1, r = document, o = r.documentElement, s = o.doScroll, c = 'DOMContentLoaded', d = 'addEventListener', u = 'onreadystatechange', l = 'readyState', f = s ? /^loaded|^c/ : /^loaded|c/, h = f.test(r[l]); return r[d] && r[d](c, n = function () { r.removeEventListener(c, n, a), e() }, a), s && r.attachEvent(u, n = function () { (/^c/).test(r[l]) && (r.detachEvent(u, n), e()) }), t = s ? function (e) { self != top ? h ? e() : i.push(e) : (function () { try { o.doScroll('left') } catch (n) { return setTimeout(() => { t(e) }, 50) }e() }()) } : function (t) { h ? t() : i.push(t) } })), Array.prototype.indexOf ? t.indexOf = function (t, e) { return t.indexOf(e) } : t.indexOf = function (t, e) { if (typeof t == 'string') { return t.indexOf(e) } let n, i, a = e ? e : 0; if (!this) { throw new TypeError() } if (i = this.length, i === 0 || a >= i) { return -1 } for (a < 0 && (a = i - Math.abs(a)), n = a; i > n; n++) { if (this[n] === t) { return n } } return -1 }, Array.isArray ? t.isArray = function (t) { return Array.isArray(t) } : t.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]' }, Object.keys ? t.iterate = function (t, e) { if (!t) { return [] } let n, i = Object.keys(t); for (n = 0; i[n] && e(i[n], t[i[n]]) !== !1; n++) { } } : t.iterate = function (t, e) { if (!t) { return [] } let n; for (n in t) { if (Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]) === !1) { break } } }, window.matchMedia ? t.matchesMedia = function (t) { return t == '' ? !0 : window.matchMedia(t).matches } : window.styleMedia || window.media ? t.matchesMedia = function (t) { if (t == '') { return !0 } const e = window.styleMedia || window.media; return e.matchMedium(t || 'all') } : window.getComputedStyle ? t.matchesMedia = function (t) { if (t == '') { return !0 } let e = document.createElement('style'), n = document.getElementsByTagName('script')[0], i = null; e.type = 'text/css', e.id = 'matchmediajs-test', n.parentNode.insertBefore(e, n), i = 'getComputedStyle'in window && window.getComputedStyle(e, null) || e.currentStyle; const a = `@media ${t}{ #matchmediajs-test { width: 1px; } }`; return e.styleSheet ? e.styleSheet.cssText = a : e.textContent = a, i.width === '1px' } : t.matchesMedia = function (t) { if (t == '') { return !0 } let e, n, i, a, r = { 'min-width': null, 'max-width': null }, o = !1; for (i = t.split(/\s+and\s+/), e = 0; e < i.length; e++) { n = i[e], n.charAt(0) == '(' && (n = n.substring(1, n.length - 1), a = n.split(/:\s+/), a.length == 2 && (r[a[0].replace(/^\s+|\s+$/g, '')] = parseInt(a[1]), o = !0)) } if (!o) { return !1 } let s = document.documentElement.clientWidth, c = document.documentElement.clientHeight; return r['min-width'] !== null && s < r['min-width'] || r['max-width'] !== null && s > r['max-width'] || r['min-height'] !== null && c < r['min-height'] || r['max-height'] !== null && c > r['max-height'] ? !1 : !0 }, navigator.userAgent.match(/MSIE ([0-9]+)/) && RegExp.$1 < 9 && (t.newStyle = function (t) { const e = document.createElement('span'); return e.innerHTML = `&nbsp;<style type="text/css">${t}</style>`, e }) }, initVars() { let e, n, i, a = navigator.userAgent; e = 'other', n = 0, i = [['firefox', /Firefox\/([0-9\.]+)/], ['bb', /BlackBerry.+Version\/([0-9\.]+)/], ['bb', /BB[0-9]+.+Version\/([0-9\.]+)/], ['opera', /OPR\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)/], ['edge', /Edge\/([0-9\.]+)/], ['safari', /Version\/([0-9\.]+).+Safari/], ['chrome', /Chrome\/([0-9\.]+)/], ['ie', /MSIE ([0-9]+)/], ['ie', /Trident\/.+rv:([0-9]+)/]], t.iterate(i, (t, i) => { return a.match(i[1]) ? (e = i[0], n = parseFloat(RegExp.$1), !1) : void 0 }), t.vars.browser = e, t.vars.browserVersion = n, e = 'other', n = 0, i = [['ios', /([0-9_]+) like Mac OS X/, function (t) { return t.replace('_', '.').replace('_', '') }], ['ios', /CPU like Mac OS X/, function (t) { return 0 }], ['wp', /Windows Phone ([0-9\.]+)/, null], ['android', /Android ([0-9\.]+)/, null], ['mac', /Macintosh.+Mac OS X ([0-9_]+)/, function (t) { return t.replace('_', '.').replace('_', '') }], ['windows', /Windows NT ([0-9\.]+)/, null], ['bb', /BlackBerry.+Version\/([0-9\.]+)/, null], ['bb', /BB[0-9]+.+Version\/([0-9\.]+)/, null]], t.iterate(i, (t, i) => { return a.match(i[1]) ? (e = i[0], n = parseFloat(i[2] ? i[2](RegExp.$1) : RegExp.$1), !1) : void 0 }), t.vars.os = e, t.vars.osVersion = n, t.vars.IEVersion = t.vars.browser == 'ie' ? t.vars.browserVersion : 99, t.vars.touch = t.vars.os == 'wp' ? navigator.msMaxTouchPoints > 0 : Boolean('ontouchstart'in window), t.vars.mobile = t.vars.os == 'wp' || t.vars.os == 'android' || t.vars.os == 'ios' || t.vars.os == 'bb' } }; return t.init(), t }()); !(function (t, e) { typeof define == 'function' && define.amd ? define([], e) : typeof exports == 'object' ? module.exports = e() : t.skel = e() }(this, () => { return skel }))
